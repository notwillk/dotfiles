#!/usr/bin/env bash
set -euo pipefail

is_absolute_path() { [[ "$1" = /* ]] }

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RULE_FILE_MATCHER="../rules.d/*.rule.sh"
abs_glob=$(is_absolute_path "$RULE_FILE_MATCHER" && echo "$RULE_FILE_MATCHER" || echo "$DIR/$RULE_FILE_MATCHER")
CMD=""
TARGET_ID=""
VERBOSE=0
DOTFILES_PATH="${DOTFILES_PATH:-$HOME/.dotfiles}"

args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --verbose|-v) VERBOSE=1; shift ;;
    --rules) RULE_FILE_MATCHER="$2"; shift 2 ;;
    list|check|fix) CMD="$1"; shift; TARGET_ID="${1:-}"; [ -n "$TARGET_ID" ] && shift || true ;;
    *) args+=("$1"); shift ;;
  esac
done

if ((${#args[@]})); then
  set -- "${args[@]}"
else
  set --
fi

verbose_log() { [[ $VERBOSE -eq 1 ]] && echo "$*" || true; }
has(){ declare -F "$1" >/dev/null 2>&1; }
unload_file(){ unset ID DESCRIPTION applies check can_fix fix; }
load_file(){
  unload_file
  # shellcheck disable=SC1090
  . "$1"
}

usage() {
  cat >&2 <<USAGE
usage: $(basename "$0") [--verbose] [--rules <glob>] list [<rule-id>]
       $(basename "$0") [--verbose] [--rules <glob>] check [<rule-id>]
       $(basename "$0") [--verbose] [--rules <glob>] fix [<rule-id>]
USAGE
  exit 2
}

if [[ "$CMD" != "list" && "$CMD" != "check" && "$CMD" != "fix" ]]; then
  usage
fi

verbose_log "‚ÑπÔ∏è  Rules: $RULE_FILE_MATCHER"
verbose_log "‚ÑπÔ∏è  Command: $CMD"
if [[ -n "$TARGET_ID" ]]; then
  verbose_log "‚ÑπÔ∏è  Rule ID: $TARGET_ID"
else
  verbose_log "‚ÑπÔ∏è  Rule ID: *"
fi

mapfile -t RULE_FILES < <(compgen -G "$abs_glob" || true)
IFS=$'\n' RULE_FILES=($(printf '%s\n' "${RULE_FILES[@]}" | sort)); unset IFS

if ((${#RULE_FILES[@]}==0)); then
  echo "üôà  no matching rules in $RULE_FILE_MATCHER"
  exit 0
fi

RC=0
FIXED=0
for file in "${RULE_FILES[@]}"; do
  file="$(realpath "$file")"
  load_file "$file"


  verbose_log "üìÑ Rule file: $file"
  verbose_log "üì£  Rule ID: $ID"
  verbose_log "üí°  Rule description: $DESCRIPTION"

  if [[ -n "$TARGET_ID" && "$TARGET_ID" != "$ID" ]]; then
    verbose_log "‚è≠Ô∏è  Skipping rule $ID"
    break
  fi

  if [[ "$CMD" != "list" ]] && has applies && ! applies "$VERBOSE"; then
    echo "‚è≠Ô∏è  Skipped: $ID"
    break
  fi

  case "$CMD" in
    list) echo "üìã $ID - $DESCRIPTION" ;;
    check) check "$VERBOSE" && echo "‚úÖ $ID" || { echo "‚ùå $ID"; RC=1; } ;;
    fix)
      if check "$VERBOSE"; then
        echo "‚úÖ $ID"
      else
        echo "‚ùå $ID"
        if has can_fix && ! can_fix "$VERBOSE"; then
          echo "üôÖ [$ID] cannot auto-fix"
          RC=1
        elif has fix; then
          if fix "$VERBOSE" && check "$VERBOSE"; then
            echo "üõ†Ô∏è $ID - fixed!"
            FIXED=$((FIXED + 1))
          else
            echo "üò≠ $ID - fix failed"
            RC=1
          fi
        else
          echo "ü§∑ [$ID] no fix defined"
          RC=1
        fi
      fi
      ;;
  esac

  unload_file
done

if (( FIXED > 0 )); then
  echo "‚ö†Ô∏è  Done, you may need to restart your shell for changes to take effect"
fi

exit "$RC"
